from contextlib import ContextDecorator
from dataclasses import dataclass, field
from functools import cache, wraps
from itertools import count
from typing import Any, Callable, List, Mapping, Tuple
import re
from boltons.funcutils import make_sentinel
from pymitter import EventEmitter
import inspect

# Uncomment to test number of imports is 1 to make sure DefaultProviderContext is shared.
# print("Importing provider...")

# module level sentinel for nothing
NOTHING = make_sentinel("NOTHING", var_name="NOTHING")


# provider event types
EVENT_TYPES = {
    # Accepts [key, default, default_factory]
    "key.requested": Callable[[str, Any, Callable[[], Any]], None],
    # Accepts [value, key, was found?, fullpath, provider instance]
    "key.returned": Callable[[Any, str, bool, str, "Provider"], None],
    # Accepts [provider instance]
    "activate.pre": Callable[["Provider"], None],
    # Accepts [provider instance]
    "deactivate.pre": Callable[["Provider"], None],
}


@dataclass
class ProviderBuildContext:
    name: str
    # List of active providers
    active_trace: List["Provider"] = field(default_factory=list)
    # List of all providers
    providers: List["Provider"] = field(default_factory=list)
    # Eventbus
    eventbus: EventEmitter = field(default_factory=EventEmitter)

    def append_provider(self, provider: "Provider"):
        self.providers.append(provider)

    def clear_context(self):
        self.active_trace.clear()
        self.providers.clear()

    def emit_event(self, name, *args, **kwargs):
        """
        Emits event on all active providers.
        """
        assert name in EVENT_TYPES.keys()
        self.eventbus.emit(name, *args, **kwargs)


DefaultProviderContext = ProviderBuildContext(name="DefaultProviderContext")


class LambdaValue:
    def __init__(
        self,
        fn: Callable[[str, Callable[[], Any]], Any],
    ) -> None:
        """
        A LambdaValue is uses a function that accepts the following arguments,
            fullpath: str
                Full path of the found value, i.e. `{path}/{key}`
            default_generator: Callable[[], Any]
                A callable to generate the default value provided to the `Provider.get` call. This is not the same as `default_factory` argument of `Provider.get`.

        This should return a value to reply to the `Provider.get` call or it can return `provider.NOTHING` to ignore this value and keep searching for other matches.
        """
        self.value = fn


class PathCachedLambdaValue(LambdaValue):
    def __init__(
        self,
        fn: Callable[[str, Callable[[], Any]], Any],
    ) -> None:
        """
        Same as LambdaValue but the returned value is reused for the same path.
        """
        self.cache = {}

        def _fn(fullpath, default_generator):
            rt = self.cache.get(fullpath, NOTHING)
            if rt is NOTHING:
                self.cache[fullpath] = fn(fullpath, default_generator)
            return self.cache[fullpath]

        super().__init__(_fn)


class PathCachedDefaultValue(PathCachedLambdaValue):
    """
    Caches the default value generated by the first call to Provider.get(). and returns the same every subsequent call from the same path.
    """

    def __init__(self):
        super().__init__(lambda path, gen: gen())


class Provider(ContextDecorator):
    def __init__(self, name: str = None, ctx: ProviderBuildContext = None) -> None:
        self.name = name
        self.ctx = ctx or DefaultProviderContext
        self.ctx.append_provider(self)

    def __enter__(self):
        self.ctx.emit_event("activate.pre", self)
        self.ctx.active_trace.append(self)
        return self

    def __exit__(self, *exc):
        self.ctx.emit_event("deactivate.pre", self)
        self.ctx.active_trace.pop()
        return False

    @staticmethod
    def get(
        key: str,
        default: Any = NOTHING,
        default_factory: Callable[[], Any] = NOTHING,
        ctx: ProviderBuildContext = None,
    ):
        """
        Returns the value for the given key by searching this provider and its ancestors.
        """
        return Provider.get_with_path(
            key=key, ctx=ctx, default=default, default_factory=default_factory
        )[0]

    @staticmethod
    def get_with_path(
        key: str,
        default: Any = NOTHING,
        default_factory: Callable[[], Any] = NOTHING,
        ctx: ProviderBuildContext = NOTHING,
    ):
        """
        Returns the value for the given key by searching this provider and its ancestors.
        """
        ctx = ctx or DefaultProviderContext

        # emit keyrequested
        ctx.emit_event("key.requested", key, default, default_factory)

        # Setup default generator
        default_generator = (
            (lambda: default)
            if default != NOTHING
            else (default_factory or (lambda: NOTHING))
        )

        # Find value
        value = NOTHING
        names = []
        fullpath = ""
        found_in = None
        for p in reversed(ctx.active_trace):
            # make path and update name
            path = "/".join(reversed(names))
            fullpath = f"{path}/{key}"
            if p.name is not None:
                names.append(p.name)
            # visit provider to check for key
            value = p[key] or p[f"{path}/{key}"] or value
            # resolve value
            if isinstance(value, LambdaValue):
                # ensure default generator passed to LambdaValue is callable
                value = value.value(fullpath, default_generator)
            if value != NOTHING:
                # found a value yay
                found_in = p
                break
        # check key found
        found = value != NOTHING
        # else use default
        if found is False:
            value = default_generator()
            if value == NOTHING:
                raise RuntimeError(
                    f"No provided key='{key}' in context '{ctx.name}' and neither default nor default_factory was given."
                )
        # announce key returned
        ctx.emit_event("key.returned", value, key, found, fullpath, found_in)
        return value, fullpath

    def __getitem__(self, key: str):
        """
        This must always return a ProviderValue.
        """
        return NOTHING


class EventListener(Provider):
    def __init__(
        self,
        event: str,
        fn: Callable,
        name: str = None,
        ctx: ProviderBuildContext = None,
    ) -> None:
        """
        Listenes for the given event in the provider chain and calls the given function with event arguments.
        """
        super().__init__(name, ctx)
        # check valid provider events
        assert event in EVENT_TYPES.keys()
        self.ctx.eventbus.on(event, fn)


class UniqueProvider(Provider):
    """
    Every time a key is found routed through this provider, it changes its name by updating the idx after its name.
    This allows one to wrap functions where there a many get calls for the same key but all calls must result in different values.
    """

    def __init__(
        self,
        name: str = None,
        # If provided, only updates for given key
        key: str = None,
        suffix_generator: Callable[[], Any] = None,
        joining_str: str = ":",
        ctx: ProviderBuildContext = None,
    ) -> None:
        name = name or "UniqueProvider"
        suffix_generator = suffix_generator or count()
        self.key = key
        super().__init__(name, ctx)
        self.suffix_generator = suffix_generator
        self.joining_str = joining_str
        # only rename if key found
        self.ctx.eventbus.on("key.returned", self._update)
        self._update(None, key, True)

    @property
    def name(self):
        return f"{self._name}{self.joining_str}{self._suffix}"

    @name.setter
    def name(self, n):
        self._name = n

    def _update(self, val, key, found, *_):
        if (found is True) and ((self.key or key) == key):
            self._suffix = next(self.suffix_generator)


class ReplaceIfProvided(Provider):
    """
    Tries to Provider.get the value for the given key and returns it if found instead of executing/instantiating the decorated function/class.
    """

    def __init__(
        self,
        key: str,
        ctx: ProviderBuildContext = None,
    ) -> None:
        super().__init__(name="ReplacingProvider", ctx=ctx)
        self.key = key

    def __call__(self, func):
        if inspect.isclass(func) is True:
            old = func.__new__

            def new(cls, *a, **k):
                return Provider.get(
                    self.key,
                    default_factory=lambda: super(cls.__class__, cls).__new__(cls),
                )

            func.__new__ = new
            return func

        # See: contextlib.ContextDecorator
        @wraps(func)
        def inner(*args, **kwds):
            with self._recreate_cm():
                return Provider.get(
                    self.key, default_factory=lambda: func(*args, **kwds)
                )

        return inner


class DictProvider(Provider):
    def __init__(
        self,
        data: Mapping[str, Any],
        name: str = None,
        ctx: ProviderBuildContext = None,
    ) -> None:
        super().__init__(name, ctx)
        self.data = data

    def __getitem__(self, key: str):
        return self.data.get(key, NOTHING)


class RegexProvider(Provider):
    def __init__(
        self,
        data: List[Tuple[str, Any]],
        name: str = None,
        ctx: ProviderBuildContext = None,
    ) -> None:
        super().__init__(name, ctx)
        # compile regex
        self.data = [(re.compile(exp), v) for exp, v in data]

    @cache
    def __getitem__(self, key: str):
        # matches bottom-up
        for x, v in reversed(self.data):
            if x.fullmatch(key) is not None:
                return v
        return NOTHING
